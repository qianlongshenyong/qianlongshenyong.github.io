{"meta":{"title":"潜龙慎用","subtitle":null,"description":"扬帆起航风雨兼程，乘风破浪再接再厉；高瞻远瞩坚定目标，无怨无悔直达彼岸。","author":"潜龙慎用","url":"https://qianlongshenyong.github.io","root":"/"},"pages":[{"title":"","date":"2019-06-29T09:33:06.733Z","updated":"2019-06-29T09:33:06.733Z","comments":true,"path":"about/index.html","permalink":"https://qianlongshenyong.github.io/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2019-06-29T07:33:32.000Z","updated":"2019-06-29T07:34:14.409Z","comments":true,"path":"categories/index.html","permalink":"https://qianlongshenyong.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2019-06-29T07:32:07.000Z","updated":"2019-06-29T07:32:54.392Z","comments":true,"path":"tags/index.html","permalink":"https://qianlongshenyong.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"前端之HTML","slug":"前端之HTML","date":"2019-07-07T08:38:17.000Z","updated":"2019-07-07T10:14:50.455Z","comments":true,"path":"2019/07/07/前端之HTML/","link":"","permalink":"https://qianlongshenyong.github.io/2019/07/07/前端之HTML/","excerpt":"","text":"1 HTML概述 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML是一个标准,规定了大家怎么写网页. HTML基本概念 1.1标签 HTML 标签是由尖括号包围的关键词，比如 HTML 标签通常是成对出现的，标签对中的第一个标签是开始标签，第二个标签是结束标签 标签与标签之间是可以嵌套的，但先后顺序必须保持一致，如：里嵌套，那么必须放在的前面。 1.2元素HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。 1.2.1 嵌套的 HTML 元素大多数 HTML 元素可以嵌套（可以包含其他 HTML 元素）。 HTML 文档由嵌套的 HTML 元素构成。 1.2 .2html元素12345678910 Title This is my first paragraph. 是说明这个是一个网页。告诉浏览器这个网页的开始和结束。他包含了之后的两个元素。和|和 元素定义了整个 HTML 文档。 这个元素拥有一个开始标签 ，以及一个结束标签 。 元素内容是另一个 HTML 元素（body 元素）和（head 元素） 1.2.3 head 元素：1234 Title head>和之间的内容，是元信息和网站的标题 元信息一般是不显示出来的,但是记录了你这个HTML文件的很多有用的信息 1.2.4 body元素：123This is my first paragraph. 和之间的内容，是浏览器呈现出来的，用户看到的页面效果。也就是说这里是网页的主体。也就是body的身体之意 1.2.5 段落 元素1This is my first paragraph. 这个 元素定义了 HTML 文档中的一个段落。 这个元素拥有一个开始标签，以及一个结束标签 。 元素内容是：This is my first paragraph。 1.2.6 空的 HTML 元素没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。 就是没有关闭标签的空元素. 1.3属性HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。 属性总是以名称/值对的形式出现，比如：name=”value”。 属性总是在 HTML 元素的开始标签中规定 HTML 提示：使用小写标签 HTML 标签对大小写不敏感： 等同于。许多网站都使用大写的 HTML 标签。 几个重要的属性： id：定义标签的唯一ID，HTML文档树中唯一 class：为html元素定义一个或多个类名（classname）(CSS样式类名) style：规定元素的行内样式（CSS样式） 2 HTML 文档 = 网页 HTML 文档描述网页 HTML 文档包含 HTML 标签和纯文本 HTML 文档也被称为网页 Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容： 12345678我的第一个标题","categories":[{"name":"前端","slug":"前端","permalink":"https://qianlongshenyong.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://qianlongshenyong.github.io/tags/前端/"}]},{"title":"前端","slug":"前端","date":"2019-07-07T08:21:01.000Z","updated":"2019-07-07T09:21:43.818Z","comments":true,"path":"2019/07/07/前端/","link":"","permalink":"https://qianlongshenyong.github.io/2019/07/07/前端/","excerpt":"","text":"1 前言​ 编程就是跟数据打交道，我们需要处理数据，存储数据，展示数据。什么是前端，为什么学前端。 2 web前端概述​ web前端开发是从网页制作演变而来。在互联网的演化进程中，网页制作是Web 1.0时代的产物，早期网站主要内容都是静态，以图片和文字为主，用户使用网站的行为也以浏览为主。随着互联网技术的发展和HTML5、CSS3的应用，现代网页更加美观，交互效果显著，功能更加强大。 ​ 学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言。 HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。 CSS样式是表现。比如标题字体、颜色变化或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。 JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。 3 web服务本质 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"前端","slug":"前端","permalink":"https://qianlongshenyong.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://qianlongshenyong.github.io/tags/前端/"}]},{"title":"django基本流程","slug":"Django基本流程","date":"2019-07-03T08:21:01.000Z","updated":"2019-07-07T09:47:19.353Z","comments":true,"path":"2019/07/03/Django基本流程/","link":"","permalink":"https://qianlongshenyong.github.io/2019/07/03/Django基本流程/","excerpt":"","text":"1 设计表结构 注：mysql的安装与使用 2 配置数据库2.1 默认SQLite数据库打开mysite/settings.py配置文件，这是整个Django项目的设置中心。Django默认使用SQLite数据库，因为Python源生支持SQLite数据库，所以你无须安装任何程序，就可以直接使用它。 123456789# Database# https://docs.djangoproject.com/en/2.2/ref/settings/#databasesDATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), }} 如果你想使用其他的数据库，请先安装相应的数据库操作模块，并将settings文件中DATABASES位置的’default’的键值进行相应的修改，用于连接你的数据库。其中： ENGINE（引擎）：可以是django.db.backends.sqlite3、django.db.backends.postgresql、django.db.backends.mysql、django.db.backends.oracle，当然其它的也行。 NAME（名称）：类似Mysql数据库管理系统中用于保存项目内容的数据库的名字。如果你使用的是默认的SQLite，那么数据库将作为一个文件将存放在你的本地机器内，此时的NAME应该是这个文件的完整绝对路径包括文件名，默认值os.path.join(BASE_DIR, ’db.sqlite3’)，将把该文件储存在你的项目目录下。 2.2 更换其他数据库注：如果你不是使用默认的SQLite数据库，那么一些诸如USER，PASSWORD和HOST的参数必须手动指定！mysql 示例： 1234567891011121314151617181920# mysite/settings.py# Database# https://docs.djangoproject.com/en/1.11/ref/settings/#databasesimport pymysql # 一定要添加这两行！通过pip install pymysql！pymysql.install_as_MySQLdb()#因为Django连接MySQL时默认使用MySQLdb驱动，但MySQLdb不支持Python3，因此这里将MySQL#驱动设置为pymysql。DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'mysite', 'HOST': '192.168.1.1', 'USER': 'root', 'PASSWORD': 'pwd', 'PORT': '3306', }} 注意： 在使用非SQLite的数据库时，请务必预先在数据库管理系统的提示符交互模式下创建数据库，你可以使用命令：CREATE DATABASE database_name; Django不会自动帮你做这一步工作。 确保你在settings文件中提供的数据库用户具有创建数据库表的权限，因为在接下来的教程中，我们需要自动创建一个test数据表。（在实际项目中也需要确认这一条要求。） 如果你使用的是SQLite，那么你无需做任何预先配置，直接使用就可以了。 2.3 错误错误1： 12345678No module named 'MySQLdb'原因：python3连接MySQL不能再使用mysqldb，取而代之的是pymysql。解决方法：在python的MySQL包中，即路径：C:\\Users\\adong\\AppData\\Local\\Programs\\Python\\Python36\\Lib\\site-packages\\Django-2.0.3-py3.6.egg\\django\\db\\backends\\mysql下的__init__.py文件中加入：import pymysqlpymysql.install_as_MySQLdb() 错误2： 123456789django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.3 or newer is required; you have 0.7.11.None原因：在解决了错误一以后出现了此错误。解决方法：在python的MySQL包中，即路径：C:\\Users\\adong\\AppData\\Local\\Programs\\Python\\Python36\\Lib\\site-packages\\Django-2.0.3-py3.6.egg\\django\\db\\backends\\mysql下的 base.py 文件中，注释掉一下两行代码：if version < (1, 3, 3): raise ImproperlyConfigured(\"mysqlclient 1.3.3 or newer is required; you have %s\" % Database.__version__) 错误3： 123python3报错：Attribute Error:str object has no attribut edecode 错误代码：query = query.encode(errors='replace')解决方法：把decode改为encode即可。 3 创建应用3.1 命令创建在 Django 中，每一个应用（app）都是一个 Python 包，并且遵循着相同的约定。Django 自带一个工具，可以帮你生成应用的基础目录结构。 app应用与project项目的区别： 一个app实现某个功能，比如博客、公共档案数据库或者简单的投票系统； 一个project是配置文件和多个app的集合，这些app组合成整个站点； 一个project可以包含多个app； 一个app可以属于多个project！ app的存放位置可以是任何地点，但是通常都将它们放在与manage.py脚本同级的目录下，这样方便导入文件 进入mysite项目根目录，确保与manage.py文件处于同一级，输入下述命令： 1python manage.py startapp appname 系统会自动生成 polls应用的目录，其结构如下： 123456789appname/ __init__.py ---说明app应用是一个包 admin.py ---站点配置 apps.py migrations/ __init__.py models.py ---模型 tests.py views.py ---视图（url-->视图-->models取数据-->视图在将数据给模板） 3.2 pycharm中创建在Pycharm中，没有可以创建app的图形化按钮，需要在下方的Terminal终端中输入命令： python manage.py startapp appname 通过前面在Pycharm中创建工程的方式有个方便之处，点击Terminal后，会自动进入虚拟环境。 注：如果没有进入venv环境，则执行语句报错！ 4 激活应用在settings文件中顶部的INSTALLED_APPS设置项。它列出了所有的项目中被激活的Django应用（app）。你必须将你自定义的app注册在这里。每个应用可以被多个项目使用，并且可以打包和分发给其他人在他们的项目中使用。 默认情况，INSTALLED_APPS中会自动包含下列条目，它们都是Django自动生成的： django.contrib.admin：admin管理后台站点 django.contrib.auth：身份认证系统 django.contrib.contenttypes：内容类型框架 django.contrib.sessions：会话框架 django.contrib.messages：消息框架 django.contrib.staticfiles：静态文件管理框架 上面的一些应用也需要建立一些数据库表，所以在使用它们之前我们要在数据库中创建这些表， migrate命令将遍历INSTALLED_APPS设置中的所有项目，在数据库中创建对应的表，并打印出每一条动作信息 12345678910# Application definitionINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] 5 定义模型模型本质上就是数据库表的布局，再附加一些元数据。 Django通过自定义Python类的形式来定义具体的模型，每个模型的物理存在方式就是一个Python的类Class，每个模型代表数据库中的一张表，每个类的实例代表数据表中的一行数据，类中的每个变量代表数据表中的一列字段。Django通过模型，将Python代码和数据库操作结合起来，实现对SQL查询语言的封装。也就是说，你可以不会管理数据库，可以不会SQL语言，你同样能通过Python的代码进行数据库的操作。Django通过ORM对数据库进行操作，奉行代码优先的理念，将Python程序员和数据库管理员进行分工解耦。 现在编辑myapp/models.py文件 1234567891011121314# polls/models.pyfrom django.db import modelsclass Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published')class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) 注： 首先要引入from django.db import models, 因为每一个类都是django.db.models.Model的子类。每一个字段都是Field类的一个实例。例如用于保存字符数据的CharField和用于保存时间类型的DateTimeField，它们告诉Django每一个字段保存的数据类型。 每一个Field实例的名字就是字段的名字（如： question_text 或者 pub_date ）。在你的Python代码中会使用这个值，你的数据库也会将这个值作为表的列名。 一些Field类必须提供某些特定的参数。例如CharField需要你指定max_length。这不仅是数据库结构的需要，同样也用于数据验证功能。 有必填参数，当然就会有可选参数，比如在votes里我们将其默认值设为0. 最后请注意，我们使用ForeignKey定义了一个外键关系。它告诉Django，每一个Choice关联到一个对应的Question（注意要将外键写在‘多’的一方）。Django支持通用的数据关系：一对一，多对一和多对多。 6 在数据库中生成数据表需要做两步操作 生成迁移文件和执行迁移 6.1 makemigrations1python manage.py makemigrations 通过运行makemigrations命令，Django 会检测你对模型文件的修改，也就是告诉Django你对模型有改动，并且你想把这些改动保存为一个“迁移(migration)”。 migrations是Django保存模型修改记录的文件，这些文件保存在磁盘上。会在 migrations下生成一个0001_initial.py文件，面保存的都是人类可读并且可编辑的内容，方便随时手动修改。 在例子中，它就是polls/migrations/0001_initial.py，你可以打开它看看，里面保存的都是人类可读并且可编辑的内容，方便你随时手动修改。 123注：通过执行python manage.py sqlmigrate appname 0001命令可以看到在migration的时候实际执行的SQL语句是什么。执行python manage.py check命令，它将检查项目中的错误，并不实际进行迁移或者链接数据库的操作 6.2 migrate运行migrate命令，在数据库中进行真正的表操作了。 python manage.py migrate 1234567show databases;use 数据库名称；show tables；select * from 表名；desc 表名；create database databasename；drop database databasename； migrate命令对所有还未实施的迁移记录进行操作，本质上就是将你对模型的修改体现到数据库中具体的表上面。Django通过一张叫做django_migrations的表，记录并跟踪已经实施的migrate动作，通过对比获得哪些migrations尚未提交。 migrations的功能非常强大，允许你随时修改你的模型，而不需要删除或者新建你的数据库或数据表，在不丢失数据的同时，实时动态更新数据库 修改模型时的操作分三步 在models.py中修改模型； 运行python manage.py makemigrations为改动创建迁移记录； 运行python manage.py migrate，将操作同步到数据库。 之所以要将创建和实施迁移的动作分成两个命令两步走是因为你也许要通过版本控制系统（例如github，svn）提交你的项目代码，如果没有一个中间过程的保存文件（migrations），那么github如何知道以及记录、同步、实施你所进行过的模型修改动作呢？毕竟，github不和数据库直接打交道，也没法和你本地的数据库通信。但是分开之后，你只需要将你的migration文件（例如上面的0001）上传到github，它就会知道一切。 6.3 错误1234Django在根据models生成数据库表时报 init() missing 1 required positional argument: 'on_delete'解决办法:在django2.0后，定义外键和一对一关系的时候需要加on_delete选项，此参数为了避免两个表里的数据不一致问题，不然会报错：https://www.cnblogs.com/phyger/p/8035253.html 7 使用模型的API模型、数据库表、 数据库数据之间的使用。 注：一般是在view（视图）中使用，视图通过使用模型的api去获取数据，然后将数据传递给模板，模板经过渲染之后再浏览器进行显示。下面的测试使用python的shell环境进行测试。 7.1 进入Python的shell通过python manage.py shell进入Python的shell环境，相比较直接输入“python”命令的方式进入Python环境，调用manage.py参数能将DJANGO_SETTINGS_MODULE环境变量导入，它将自动按照mysite/settings.py中的设置，配置好你的python shell环境，这样，你就可以导入和调用任何你项目内的模块了。 7.2 导入包12345>>>from myapp.models import Grades,Students #引入我们在模型中定义的类>>>from django.utils import timezone #Django推荐使用timezone.now()代替python内置的datetime.datetime.now()# 这个timezone就来自于Django的依赖库pytz>>>from datetime import * #导入 python自带的datetime模块 7.3 查询所有数据object是模型属性—用于模型对象和数据库交互 . objects = Manager（） 是管理器类型的对象 ,是Model和数据库进行查询的接口。 定义在from django.db import models中用于模型对象和数据库交互是默认自动生成的属性，但我们是可以自定义管理器对象。 如果不自己定义，objects=models.Manager()查询类的属性时都是类名.objects.方法 123>>> Students.objects.all()#现在系统中没有Students对象，数据库中没有数据 7.4 添加数据 1234567>>> grade1=Grades()>>> grade1.gname=\"python04\">>> grade1.gdate=datetime(year=2017,month=7,day=17)>>> grade1.ggirlnum=3>>> grade1.gboynum=70#必须调用save()函数才能在数据库中添加数据>>> grade1.save() 添加数据后，再次进行查询： 12>>> Grades.objects.all() 上面的是一个不可读的内容展示，你无法从中获得任何直观的信息，为此我们需要一点小技巧，让Django在打印对象时显示一些我们指定的信息。 返回myapp/models.py文件，修改一下类，代码如下： 12345678class Grades(models.Model): gname = models.CharField(max_length=20) gdate = models.DateTimeField() ggirlnum = models.IntegerField() gboynum = models.IntegerField() isDelete = models.BooleanField(default=False) def __str__(self): return self.gname 退出shell 环境，然后重新进入，另需要重新导入模块： 12345>>>from myapp.models import Grades,Students >>>from django.utils import timezone >>>from datetime import * >>>Grades.objects.all() 7.5 查看对象Django提供了大量的关键字参数查询API 123456789101112131415161718 >>>Grades.objects.filter(id=1)>>> Grades.objects.filter(gname='python04')>>> Grades.objects.filter(gboynum=33)>>> Grades.objects.filter(ggirlnum=3)# 查询一个不存在的ID，会弹出异常>>> Grades.objects.get(id=3)myapp.models.Grades.DoesNotExist: Grades matching query does not exist.# Django为主键查询提供了一个缩写：pk。与Grades.objects.get(id=1)效果相同>>> Grades.objects.get(pk=1) Django提供了大量的关键字参数查询API pycharm中 .idea文件 7.6 修改数据通过python的属性调用方式，访问模型字段的值 通过修改属性来修改字段的值，然后显式的调用save方法进行保存。 7.7 删除数据 7.8 关联对象 获取关联对象的集合： 问题：如果表的关联很多，一环扣一环怎么办？ 123>>> stu2=Students(sname=\"jone\",sage=30,scontend=\"我是jone\",sgrade=grade1)>>> stu2.save()问题：如果关联不存在，怎么办？ 8 启动服务器 9 admin站点管理​ 很多时候，我们不光要开发针对客户使用的前端页面，还要给后台管理人员提供相应的管理界面。但是大多数时候为你的团队或客户编写用于增加、修改和删除内容的后台管理站点是一件非常乏味的工作并且没有多少创造性，而且也需要花不少的时间和精力。Django最大的优点之一，就是体贴的为你提供了一个基于项目model创建的一个后台管理站点admin。这个界面只给站点管理员使用，并不对大众开放。虽然admin的界面可能不是那么美观，功能不是那么强大，内容不一定符合你的要求，但是它是免费的、现成的，并且还是可定制的 负责添加、修改、删除内容，内容指的是数据，数据库中的数据，通过可视化界面来修改数据。 公告访问：一般不需要 9.1 配置Admin应用 9.2 创建管理员用户 首先，我们需要通过下面的命令，创建一个可以登录admin站点的用户： 1python manage.py createsuperuser 输入用户名： 1Username: admin 输入邮箱地址： 1Email address: xxx@xxx.xxx 输入密码： 123Password: **********Password (again): *********Superuser created successfully. 修改密码： 方法一 在Terminal中执行：python manage.py changepassword your_name（其中“your_name”为你要修改密码的用户名），根据提示内容修改即可。 方法二 进入shell环境，执行： 1234from django.contrib.auth.models import Useru = User.objects.get(username='your_name')u.set_password('new_password')u.save() 比较 方法一有密码强度验证，方法二不会校验密码强度 9.3 启动开发服务器服务器启动后，在浏览器访问http://127.0.0.1:8000/admin/。你就能看到admin的登陆界面了： 在实际环境中，为了站点的安全性，我们一般不能将管理后台的url随便暴露给他人，不能用/admin/这么简单的路径。 打开根url路由文件mysite/urls.py，修改其中admin.site.urls对应的表达式 123456from django.contrib import adminfrom django.urls import pathurlpatterns = [ path('control/', admin.site.urls),] 这样，我们必须访问http://127.0.0.1:8000/control/才能进入admin界面。 9.4 汉化1234LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/shanghai'#注：不需要重启服务，直接刷新页面就好 当前只有两个可编辑的内容：groups和users。它们是django.contrib.auth模块提供的身份认证框架。 9.5 管理数据表9.5.1修改admin.py文件在 app 中存在admin.py文件，进行修改。 导入类（表） 进行注册 12345from django.contrib import adminfrom .models import Grades,Students# Register your models here.admin.site.register(Grades)admin.site.register(Students) 9.5.2 自定义管理界面点击进入 ，界面不友好，进行修改，则需要自定义管理界面： 自定义管理界面步骤： 定义类，继承admin.ModelAdmin 在类中添加属性 注册 问题：admin管理注册的时候，可以所有类一起进行注册吗？ 答：不能，看admin.site.register()函数的参数 属性说明 添加list_display: 123456from django.contrib import adminfrom .models import Grades,Students# Register your models here.class GradesAdmin(admin.ModelAdmin): list_display = ['pk', 'gname', 'gdate', 'ggirlnum', 'gboynum','isDelete']admin.site.register(Grades,GradesAdmin) 添加 list_filter: 1list_filter = [\"gname\"] 1list_filter = [\"gname\",\"gdate\"] 添加search_fields 1search_fields = [\"gname\"] 添加 list_per_page 1list_per_page = 5 区分添加页和修改页 添加页：点击右上角的添加GRADES 修改页:点击具体某一条数据 123fields ：修改显示的顺序fieldsets ：分组显示两者不能同时用，只是针对添加页和修改页起作用 关联对象： 需要三步： 需要 创建一个类，继承admin.TabularInline或者admin.StackedInline 需要设置model和extra两个变量 需要在GradesAdmin类中添加inlines 布尔值显示问题：字段类型为布尔值变量，显示的时候如果想要显示代表的含义，则需要自定义函数： 定义一个函数，进行判断，然后在list_display中将函数传入。 执行动作的位置如图：目前执行动作位置在左上角，可以进行调整。 123# 执行动作的位置actions_on_top = Falseactions_on_bottom = True 9.5.3 使用装饰器进行注册 10 视图的基本使用10.1 概述一个视图就是一个页面，通常提供特定的功能，使用特定的模板。 10.2 编写视图编写一个简单的视图：（没有用到模板） 导入HttpResponse 定义函数 12345from django.http import HttpResponsedef index(request) #第一个参数：一般是requset 请求体 浏览器发送给服务器的#return httpResponse（） 服务器给浏览器返回的内容return HttpResponse(\"sunck is a good man\") 10.3 配置url 修改project目录下的url.py文件 在myapp应用目录下创建一个url.py文件 关于urlconf： https://blog.csdn.net/sinat_38369128/article/details/81702636 第一，目前 路由（url）到视图（View）的流程可以概括为四个步骤： url匹配 正则捕获 变量类型转化 视图调用 Django2.0 和之前相比多了 变量类型转化 这一步骤。 第二，新的path语法可以解决一下以下几个场景： 类型自动转化 公用正则表达式 每个视图至少做两件事之一：返回一个包含请求页面的HttpResponse对象或者弹出一个类似Http404的异常。 11 模板的基本使用 11.1 概述模板是HTML页面，可以根据视图中传过来的数据进行填充。 11.2 创建模板的目录方法1： 在与应用app同级目录下创建一个templates的文件，然后在该目录下创建对应应用的模板目录。 方法2：在应用目录下创建一个新的templates目录，Django会在它里面查找模板文件 11.3 配置模板路径：12345678910111213141516TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, },] 项目的 TEMPLATES配置项描述了 Django 如何载入和渲染模板 'BACKEND': 'django.template.backends.django.DjangoTemplates',默认的设置文件设置了 DjangoTemplates 后端 12BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))#变量__file__表示文件本身，输出的是一个绝对路径 将 APP_DIRS设置成了 True。这一选项将会让 DjangoTemplates 在每个 INSTALLED_APPS 文件夹中寻找 “templates” 子目录 11.4 定义模板12 流程梳理 参考： http://www.liujiangblog.com/blog/36/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"django","slug":"django","permalink":"https://qianlongshenyong.github.io/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"https://qianlongshenyong.github.io/tags/django/"}]},{"title":"django创建项目","slug":"django创建项目","date":"2019-07-02T08:21:01.000Z","updated":"2019-07-07T09:56:25.647Z","comments":true,"path":"2019/07/02/django创建项目/","link":"","permalink":"https://qianlongshenyong.github.io/2019/07/02/django创建项目/","excerpt":"","text":"1. 在cmd或Linux命令行环境下创建Django项目1.1 创建django工程在windows的cmd环境中(Linux中类同)，新建或者进入你想创建Django项目的目录，然后输入下面的命令： django-admin startproject mysite 这样就会在当前目录下创建一个叫做mysite的Django项目 12345678910D:\\test>django-admin startproject mysiteD:\\test>dir D:\\test 的目录2019/4/20 11:19 .2019/4/20 11:19 ..2019/4/20 11:19 mysite 0 个文件 0 字节 3 个目录 102,160,605,184 可用字节 可以看到Django自动帮我们创建了一个mysite文件夹，这是项目的根目录。 在mysite根目录中，又有一个mysite目录，这是整个项目的配置文件目录（一定不要和同名的根目录搞混淆了），还有一个manage.py文件，是整个项目的管理脚本 1.2 django项目目录说明12345678---mysite 外层的mysite/目录与Django无关，只是你项目的容器，可以任意重命名。 | db.sqlite3 | manage.py 一个命令行工具，可以使我们用多种方式对Django项目进行交互 ---mysite | settings.py 项目的配置文件 | urls.py 项目的url声明 | wsgi.py 项目与wsgi兼容的web服务器入口 | init.py 一个空文件，它告诉python这个目录应该被视为一个python包 1.3 运行django在项目根目录下，运行python manage.py runserver，Django会以127.0.0.1:8000这个默认配置启动开发服务器。 Django提供了一个用于开发的web服务器，使你无需配置一个类似Ngnix的生产服务器，就能让站点运行起来。这是一个由Python编写的轻量级服务器，简易并且不安全，因此不要将它用于生产环境。 注： Django的开发服务器（以后简称服务器）默认运行在内部的8000端口，如果你想指定端口，请在命令中显示给出： 1python manage.py runserver 8080 如果想修改服务器的ip地址 1python manage.py runserver 0:8000 0 是 0.0.0.0 的简写，Django将运行在0.0.0.0:8000上，整个局域网内都将可以访问站点，而不只是是本机 2. 在windows下使用Pycharm创建Django工程2018以后的Pycharm版本都支持同时创建虚拟环境和Django工程 首先打开Pycharm，点击file-->new project，出现下面的对话框，注意下面的红框提示： 在Location处选择工程目录 在New environment using处选择Virtualenv（这可能需要你提前pip install virtualenv进行虚拟工具virtualenv的安装）。通常情况下，虚拟环境会以venv的名字，自动在工程目录下生成。 在Base interpreter处，选择你要使用的Python解释器 下面两个单选框，根据需要自行选择 如果想使用现成的解释器或者虚拟环境，请选择Existing interpreter 再点开下方的More Settings： Template language:选择使用的模板语言，默认Django就行，可选Jinjia。 Templates folder：Pycharm安利给我们的功能，额外创建一个工程级别的模板文件的保存目录，可以不设置，空着，这里使用默认设置吧。 启用Admin，一般勾上。 没什么问题了，就点击Create吧。 下面就是一段时间的等待，Pycharm会帮助我们自动创建虚拟环境，以及安装最新版本的Django。 创建完成之后，进入Pycharm的设置菜单，可以看到当前Django版本是最新的2.2版本。如果你要指定过去的版本，比如2.1、1.11等，那就不能这么操作了，需要在命令行下自己创建虚拟环境并安装django。或者在这里先删除Django，再安装你想要的指定版本。 看下我们当前的状态，注意venv这个虚拟环境目录，以及我们额外创建的templats目录： 点击绿色的三角，启动默认的开发服务器，如果看到欢迎界面，说明一切OK! 注：使用pycharm在离线环境下安装，容易出现问题：因为需要通过pip安装django 问题：在pycharm中settings 这个的作用 参考： pycharm创建django项目 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"django","slug":"django","permalink":"https://qianlongshenyong.github.io/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"https://qianlongshenyong.github.io/tags/django/"}]},{"title":"django安装","slug":"django安装","date":"2019-07-01T08:21:01.000Z","updated":"2019-07-07T09:47:19.346Z","comments":true,"path":"2019/07/01/django安装/","link":"","permalink":"https://qianlongshenyong.github.io/2019/07/01/django安装/","excerpt":"","text":"1 前言Django是由Python编写的Web框架，依赖Python环境，所以需要提前安装好Python解释器。 进行Python + Django的Web开发，最佳IDE环境是Pycharm Django对Python版本的依赖关系如下表所示： Django 版本 Python 版本 1.8 2.7, 3.2 (until the end of 2016), 3.3, 3.4, 3.5 1.9, 1.10 2.7, 3.4, 3.5 1.11 2.7，3.4，3.5，3.6，3.7 (1.11.17添加) 2.0 3.4，3.5，3.6，3.7 2.1，2.2 3.5, 3.6, 3.7 2 安装Django2.1 通过pip 安装DjangoDjango本质上是Python语言的一个类库，因此可以通过pip工具安装。这也是最简便最好的安装方式。不建议通过下载安装包或者编译源码进行安装的方法，除非你的环境无法连接外部网络。 这里介绍windows系统下pip命令安装方式。 win+r，调出cmd，运行命令：pip install django，自动安装PyPi提供的最新版本。 如果要指定版本，可使用pip install django==2.2这种形式。 在Linux操作系统中，也是一样，使用pip工具包安装Django 2.2 验证进入Python交互式环境 12import djangoprint(django.get_version()) 或者使用pip list命令，查看是否存在Django模块 2.3 配置系统环境变量成功安装Django后，以windows为例，在Python根目录下的Scripts目录中可找到一个django-admin.exe文件，这是Django的核心管理程序，最好将它加入操作系统的环境变量中，这样在以后的调用会比较方便 回到cmd界面，运行django-admin help，能看到下面的内容表示环境变量设置成功。 12345678910111213141516171819202122232425262728293031C:\\Users\\USER>django-admin helpType 'django-admin help ' for help on a specific subcommand.Available subcommands:[django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations migrate runserver sendtestemail shell showmigrations sqlflush sqlmigrate sqlsequencereset squashmigrations startapp startproject test testserver document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"django","slug":"django","permalink":"https://qianlongshenyong.github.io/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"https://qianlongshenyong.github.io/tags/django/"}]},{"title":"搭建自己的博客","slug":"搭建自己的博客","date":"2019-06-22T16:00:00.000Z","updated":"2019-06-29T07:06:58.693Z","comments":true,"path":"2019/06/23/搭建自己的博客/","link":"","permalink":"https://qianlongshenyong.github.io/2019/06/23/搭建自己的博客/","excerpt":"前言：技术：Hexo+github 好处： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 准备工作： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 搭建github博客创建仓库 登录github账号后新创建一格式为：你的用户名.github.io 比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了 点击Settings设置，然后往下拉，找到github pages，点击choose a theme选择喜欢主题 在浏览器输入 用户名.github.io访问自己博客 绑定域名配置SSH key","text":"前言：技术：Hexo+github 好处： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 准备工作： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 搭建github博客创建仓库 登录github账号后新创建一格式为：你的用户名.github.io 比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了 点击Settings设置，然后往下拉，找到github pages，点击choose a theme选择喜欢主题 在浏览器输入 用户名.github.io访问自己博客 绑定域名配置SSH key hexohexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo 原理​ 由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 hexo常用命令12345678910111213141516171819hexo g # 生成hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的hexo s # 开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容hexo clean #清理public的内容，然后再来重新生成和发布hexo d # 上传hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本缩写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy组合命令：hexo s -g #生成并本地预览hexo d -g #生成并上传 注： 执行hexo d 命令之前，可能需要安装 npm install hexo-deployer-git –save 在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 hexo环境搭建： 安装git 安装nodejs 创建存放hexo组件的目录，然后Git bash here 安装hexo npm install hexo -g hexo -v，检查hexo是否安装成功 初始化文件夹 hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： npm install 安装所需要的组件 将Hexo于Github page 联系起来，设置Git的user name 和email git config --global user.name \"qianlongshenyong\" git config --global user.email\"1320005085@qq.com\" 修改 D:\\blog\\_config.yml 并保存 hexo s 启动服务，在本地4000端口开启服务 在浏览器输入127.0.0.1:4000访问博客主页 使用Hexo修改博客主题操作步骤 选择博客主题https://hexo.io/themes/ 选择tomotoes主题 复制主题链接， D:\\blog\\themes,右键选择git bash here 下载所选主题git clone https://github.com/Tomotoes/hexo-theme-tomotoes.git 修改主题名称为tomotoes 修改 D:\\blog\\_config.yml 中theme并保存 然后在==blog目录==下打开git输入hexo s，本地预览效果. 修改主题配置按照https://github.com/Tomotoes/hexo-theme-tomotoes.git有部署文档 依赖安装还是在 Hexo 根目录，如果以下插件已安装过，无需再次安装。 Less主题默认使用 less 作为 css 预处理工具。 1$ npm install hexo-renderer-less --save Feed用于生成 rss。 1$ npm install hexo-generator-feed --save Json-content用于生成静态站点数据，用作站内搜索的数据源。 1$ npm install hexo-generator-json-content --save QRCode用于生成微信分享二维码。 1$ npm install hexo-helper-qrcode --save hexo-wordcount用来显示文章更多信息，比如：字数，阅读时间 1npm install hexo-wordcount --save hexo-abbrlink文章唯一链接，有利于SEO，主题脚本也对其有依赖 1npm install hexo-abbrlink --save hexo-filter-github-emojisEmoji插件，让文章更生动 1npm install hexo-filter-github-emojis --save 安装完成后再次运行hexo s 开启页面标签页1hexo new page tags 修改 hexo/source/tags/index.md 的元数据 12layout: tagscomments: false 分类页1hexo new page categories 修改 hexo/source/categories/index.md 的元数据 12layout: categoriescomments: false 关于页1hexo new page about 修改 hexo/source/about/index.md 的元数据 123layout: aboutcomments: truereward: false 根据需求修改主题的配置 修改 `D:\\blog_config.yml 1234567title: subtitle:description:keywords:author: peteremial: 1320005085@qq.comurl: 保存预览 npm install –save hexo-deployer-git hexo d –g 关于_config.ymlhexo的_config.yml站点配置文件，也就是站点根目录下的_config.yml配置文件 主题的_config.yml主题配置文件，位于theme文件夹中对应主题的文件夹下的_config.yml。 设置主页的Menu设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，它将用于匹配图标以及翻译。 菜单示例配置 1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 参考：https://blog.csdn.net/tonydandelion2014/article/details/61615898 hexo写博客配置完之后，有两种方法写博客。 方法1 通过hexo命令定位到blog目录下，执行hexo new 'my-first-blog'hexo会帮我们在_posts下生成相关md文件,我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 方法2 自己创建md文件通过typora等md编辑器自己创建md文件，但是必须符合以下开头。 12345678910---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---注:冒号后面必须要有空格 这是yaml语法的规定 其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 hexo new page 'postName'命令和hexo new 'postName'有什么区别呢 最终部署时生成：hexo\\public\\my-second-blog\\index.html，但是它不会作为文章出现在博文目录。 如何让博文列表不显示全部内容默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？ 答案是在合适的位置加上即可，例如： 图片设置问题解决方式是使用CodeFalling/hexo-asset-image插件。 1. post_asset_folder首先确认_config.yml中有post_asset_folder:true。 Hexo提供了一种更方便管理Asset的设定：post_asset_folder 当您设置post_asset_folder为true参数后，在建立文件时，Hexo 会自动建立一个与文章同名的文件夹；以前的文章也可以自己手动创建同名文件夹。 2. 安装 hexo-asset-image在hexo的目录下执行 1npm install https://github.com/CodeFalling/hexo-asset-image --save 3. 使用完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下： 123本地图片测试├── logo.jpg本地图片测试.md 这样的目录结构（目录名和文章名一致），只要使用 1![](本地图片测试/logo.jpg) 就可以插入图片。其中[]里面不写文字则没有图片标题。 生成的结构为 123public/2016/3/9/本地图片测试 ├── index.html ├── logo.jpg 同时，生成的 html 是 1![](/2016/3/9/本地图片测试/logo.jpg) 而不是愚蠢的 1![](本地图片测试/logo.jpg) 个人喜欢typora编辑器，在偏好设置中将图片插入设置为如下：然后只需将后缀.assets删除，即可与hexo文件夹名称相同。 常见问题： 输入hexo d –g 提示找不到git 解决办法：npm install –save hexo-deployer-git 点击主页或者归档显示找不到页面 解决办法：主题设置中有关于开启页面的指令 图片显示不出来问题 解决办法：采用CodeFalling/hexo-asset-image 参考： https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#hexo%E7%AE%80%E4%BB%8B https://blog.csdn.net/sinat_37781304/article/details/82729029 https://foxgrin.github.io/posts/29757/ https://blog.annieyu.com/posts/3333782006.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"工具","slug":"工具","permalink":"https://qianlongshenyong.github.io/categories/工具/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://qianlongshenyong.github.io/tags/Hexo/"}]}]}