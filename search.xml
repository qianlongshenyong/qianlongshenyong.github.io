<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux之ssh]]></title>
    <url>%2F2019%2Flinux%2F2019-linux-ssh%2F</url>
    <content type="text"><![CDATA[1 ssh简介SSH （Secure Shell）是建立在应用层基础上的安全协议。SSH仅仅是一协议标准，其具体的实现有很多，既有开源实现的OpenSSH，也有商业实现方案。使用范围最广泛的当然是开源实现OpenSSH。 2 ssh原理对称加密和非对称加密 ssh的原理 ssh的相关知识 https://www.cnblogs.com/diffx/p/9553587.html 数字签名 https://www.jellythink.com/archives/555 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数参数传递是传值还是传引用]]></title>
    <url>%2F2019%2Fpython%2F2019-python-python%E5%87%BD%E6%95%B0%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[1 前言在 C/C++ 中，传值和传引用是函数参数传递的两种方式，因此，在Python 函数中，参数是传值，还是传引用？ 回答这个问题前，不如先来看两段代码。 代码段1： 1234567def foo(arg): arg = 2 print(arg)a = 1foo(a) # 输出：2print(a) # 输出：1 看了代码段1的同学可能会说参数是值传递。 代码段2： 123456789def bar(args): args.append(1)b = []print(b)# 输出：[]print(id(b)) # 输出：4324106952bar(b)print(b) ＃ 输出：[1]print(id(b)) # 输出：4324106952 看了代码段2，这时可能又有人会说，参数是传引用，那么问题来了，参数传递到底是传值还是传引用或者两者都不是？ 为了把这个问题弄清楚，先了解 Python 中变量与对象之间的关系。 2 变量与对象Python 中一切皆为对象，数字是对象，列表是对象，函数也是对象，任何东西都是对象。而变量是对象的一个引用（又称为名字或者标签），对象的操作都是通过引用来完成的。例如，[]是一个空列表对象，变量 a 是该对象的一个引用 12a = []a.append(1) 在 Python 中，「变量」更准确叫法是「名字」，赋值操作 = 就是把一个名字绑定到一个对象上。就像给对象添加一个标签。例如： 1a = 1 整数 1 赋值给变量 a 就相当于是在整数1上绑定了一个 a 标签。 1a = 2 整数 2 赋值给变量 a，相当于把原来整数 1 身上的 a 标签撕掉，贴到整数 2 身上。 1b = a 把变量 a 赋值给另外一个变量 b，相当于在对象 2 上贴了 a，b 两个标签，通过这两个变量都可以对对象 2 进行操作。 变量本身没有类型信息，类型信息存储在对象中，这和C/C++中的变量有非常大的出入（C中的变量是一段内存区域） 3 函数参数Python 函数中，参数的传递本质上是一种赋值操作，而赋值操作是一种名字到对象的绑定过程，清楚了赋值和参数传递的本质之后，现在再来分析前面两段代码。 1234567def foo(arg): arg = 2 print(arg)a = 1foo(a) # 输出：2print(a) # 输出：1 在代码段1中，变量 a 绑定了 1，调用函数 foo(a) 时，相当于给参数 arg 赋值 arg=1，这时两个变量都绑定了 1。在函数里面 arg 重新赋值为 2 之后，相当于把 1 上的 arg 标签撕掉，贴到 2 身上，而 1 上的另外一个标签 a 一直存在。因此 print(a) 还是 1。 再来看一下代码段2 123456789def bar(args): args.append(1)b = []print(b)# 输出：[]print(id(b)) # 输出：4324106952bar(b)print(b) ＃ 输出：[1]print(id(b)) # 输出：4324106952 执行 append 方法前 b 和 arg 都指向（绑定）同一个对象，执行 append 方法时，并没有重新赋值操作，也就没有新的绑定过程，append 方法只是对列表对象插入一个元素，对象还是那个对象，只是对象里面的内容变了。因为 b 和 arg 都是绑定在同一个对象上，执行 b.append 或者 arg.append 方法本质上都是对同一个对象进行操作，因此 b 的内容在调用函数后发生了变化（但id没有变，还是原来那个对象） 最后，回到问题本身，究竟是是传值还是传引用呢？说传值或者传引用都不准确。非要安一个确切的叫法的话，叫传对象（call by object）。如果作为面试官，非要考察候选人对 Python 函数参数传递掌握与否，与其讨论字面上的意思，还不如来点实际代码。 4 show me the code123def bad_append(new_item, a_list=[]): a_list.append(new_item) return a_list 这段代码是初学者最容易犯的错误，用可变(mutable)对象作为参数的默认值。函数定义好之后，默认参数 a_list 就会指向（绑定）到一个空列表对象，每次调用函数时，都是对同一个对象进行 append 操作。因此这样写就会有潜在的bug，同样的调用方式返回了不一样的结果。 1234>>> print bad_append('one')['one']>>> print bad_append('one')['one', 'one'] 而正确的方式是，把参数默认值指定为None 12345def good_append(new_item, a_list=None): if a_list is None: a_list = [] a_list.append(new_item) return a_list document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python变量与赋值]]></title>
    <url>%2F2019%2Funcategorized%2Fpython%E5%8F%98%E9%87%8F%E4%B8%8E%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1 前言Python是一门独特的语言，与C语言有很大区别。 2 在c语言中在C语言中给变量赋值时，需要先指定数据类型，同时会开辟一块内存区域，用于存储值，例如 1int a = 1; a 就是内存空间中的一小块区域，就像是一个大房间里面的一个小盒子，赋值就是把整数1装载到盒子里面。 现在给变量a重新赋值 1a = 2; 盒子依然是那个盒子，也就是说内存地址没有变，只是该段内存中的值变了，变成了2。 再来看： 1int b = a; 当把变量a赋值给另外一个变量b时，相当于把值拷贝了一份传递给变量b，b是新开辟的一段内存区域。 3 在python中在Python中，“变量”的严格叫法是“名字(name)”，也可以理解为标签，就像人的姓名一样，名字就是挂在人身上的一个标签。 1234>>> 10-aTraceback (most recent call last): File "", line 1, in NameError: name 'a' is not defined 比如上面这段错误报的是name ‘a’ 没有定义，而没有说成 variable。 在Python中，给变量赋值就是相当于给对象贴标签，就像给人取名字一样，变量本身是没有任何意义的，它没有类型信息，真正的信息都在对象身上。 例如: 1a = 1 Python内部首先会分配一段内存空间用于创建整数对象1，然后给这个1贴上名为a的标签。 1a=2 Python接着会在另一块内存区域创建整数对象2，然后把标签a从1身上撕下来贴在2身上，此时，我们没法再通过a来得到1这个值了。 现在把名字a赋值给另外一个名字b 1b=a 相当于在刚才的2身上又贴了一个新的标签b，注意，这里和C语言是完全不一样的，定义b的时候不需要分配内存空间，这样我们既可以通过a来访问2也可以通过b来访问2，访问的都是同一个对象，就好比我们给宝宝取名时既有小名也有大名，其实叫的都是同一个人。 虽然我们通常在Python中还是用”变量”的叫法（因为在编程语言中这是一种通用叫法），但是我们需要理解Python中的变量不同于其他语言，变量只是一个名字。 4 函数的参数传递理解了Python中的变量与赋值后，再来看函数的参数传递，如下所示： 1234567>>> def fun_a(a):... a = a+4...>>> g = 0>>> fun_a(g)>>> g0 全局变量g传递给函数fun_a时，相当于函数中的参数a也将作为标签贴在0上，随后a被重新赋值了(a=a+4)，相当于从0撕下标签a贴到4身上，然后g依然还是0上面的标签。 再来看这个函数，传递的是一个列表对象 1>>> def fun_b(names):... names[0] = ['x', 'y']...>>> n_list = ['a','b','c']>>> fun_b(n_list)>>>>>> n_list[['x','y'], 'b', 'c'] 与前面的步骤还是一样的，names 和 n_list 都是[‘a’,’b’,’c’]上的一个标签，只是列表中的第0个元素被重新赋值了，但是names和 n_list 依然都贴在这个列表对象身上，虽然 n_list的值更新了，但对象依然是原来那个对象。就好比张三和小张都是同一个人，现在给小张换件衣服时，其实就是给张三换件衣服，人还是那个人，只是它身上的东西发生了变化。 5 变量命名规则python对字母大小写敏感。在变量命名中尽量使用小写命名。 规则： 变量名只能包含数字、字母和下划线。变量名可以以字母或下划线打头，但是不能以数字开头。 变量名不能包括空格，但是可以使用下划线来分割其中的单词。 不能使用python关键字和函数名来作为变量名。 变量名应该短而具有描述性。 6 python的关键字和内置函数 python关键字可以通过python程序查看。 1234import keyword #导入keyword模块print(keyword.kwlist)#输出结果['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] python的内置函数： 参考： Python内置函数作用及解析 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
  <entry>
    <title><![CDATA[python变量与赋值]]></title>
    <url>%2F2019%2Fpython%2F2019-python-python%E5%8F%98%E9%87%8F%E4%B8%8E%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1 前言Python是一门独特的语言，与C语言有很大区别。 2 在c语言中在C语言中给变量赋值时，需要先指定数据类型，同时会开辟一块内存区域，用于存储值，例如 1int a = 1; a 就是内存空间中的一小块区域，就像是一个大房间里面的一个小盒子，赋值就是把整数1装载到盒子里面。 现在给变量a重新赋值 1a = 2; 盒子依然是那个盒子，也就是说内存地址没有变，只是该段内存中的值变了，变成了2。 再来看： 1int b = a; 当把变量a赋值给另外一个变量b时，相当于把值拷贝了一份传递给变量b，b是新开辟的一段内存区域。 3 在python中在Python中，“变量”的严格叫法是“名字(name)”，也可以理解为标签，就像人的姓名一样，名字就是挂在人身上的一个标签。 1234>>> 10-aTraceback (most recent call last): File "", line 1, in NameError: name 'a' is not defined 比如上面这段错误报的是name ‘a’ 没有定义，而没有说成 variable。 在Python中，给变量赋值就是相当于给对象贴标签，就像给人取名字一样，变量本身是没有任何意义的，它没有类型信息，真正的信息都在对象身上。 例如: 1a = 1 Python内部首先会分配一段内存空间用于创建整数对象1，然后给这个1贴上名为a的标签。 1a=2 Python接着会在另一块内存区域创建整数对象2，然后把标签a从1身上撕下来贴在2身上，此时，我们没法再通过a来得到1这个值了。 现在把名字a赋值给另外一个名字b 1b=a 相当于在刚才的2身上又贴了一个新的标签b，注意，这里和C语言是完全不一样的，定义b的时候不需要分配内存空间，这样我们既可以通过a来访问2也可以通过b来访问2，访问的都是同一个对象，就好比我们给宝宝取名时既有小名也有大名，其实叫的都是同一个人。 虽然我们通常在Python中还是用”变量”的叫法（因为在编程语言中这是一种通用叫法），但是我们需要理解Python中的变量不同于其他语言，变量只是一个名字。 4 函数的参数传递理解了Python中的变量与赋值后，再来看函数的参数传递，如下所示： 1234567>>> def fun_a(a):... a = a+4...>>> g = 0>>> fun_a(g)>>> g0 全局变量g传递给函数fun_a时，相当于函数中的参数a也将作为标签贴在0上，随后a被重新赋值了(a=a+4)，相当于从0撕下标签a贴到4身上，然后g依然还是0上面的标签。 再来看这个函数，传递的是一个列表对象 1>>> def fun_b(names):... names[0] = ['x', 'y']...>>> n_list = ['a','b','c']>>> fun_b(n_list)>>>>>> n_list[['x','y'], 'b', 'c'] 与前面的步骤还是一样的，names 和 n_list 都是[‘a’,’b’,’c’]上的一个标签，只是列表中的第0个元素被重新赋值了，但是names和 n_list 依然都贴在这个列表对象身上，虽然 n_list的值更新了，但对象依然是原来那个对象。就好比张三和小张都是同一个人，现在给小张换件衣服时，其实就是给张三换件衣服，人还是那个人，只是它身上的东西发生了变化。 5 变量命名规则python对字母大小写敏感。在变量命名中尽量使用小写命名。 规则： 变量名只能包含数字、字母和下划线。变量名可以以字母或下划线打头，但是不能以数字开头。 变量名不能包括空格，但是可以使用下划线来分割其中的单词。 不能使用python关键字和函数名来作为变量名。 变量名应该短而具有描述性。 6 python的关键字和内置函数 python关键字可以通过python程序查看。 1234import keyword #导入keyword模块print(keyword.kwlist)#输出结果['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] python的内置函数： 参考： Python内置函数作用及解析 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符编码]]></title>
    <url>%2F2019%2Fpython%2F2019-python-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1 前言Python 开发中经常遇到编码错误，如：UnicodeDecodeError、UnicodeEncodeError，本文从字符编码的起源开始，讲述编程中应该如何应对编码的问题。 2 什么是编码字节：计算机存储的一切数据，文本字符、图片、视频、音频、软件都是由一串01的字节序列构成的，一个字节等于8个比特位。 字符：字符就是一个符号，比如一个汉字、一个英文字母、一个数字、一个标点都可以称为一个字符。 编码(encode)是把数据从一种形式转换为另外一种形式的过程，它是一套算法，比如这里的字符 A 转换成 01000001 就是一次编码的过程，解码(decode)就是编码的逆过程。本文是关于字符的编码，是字符和二进制数据（字节）之间转换的算法。 字节方便存储和网络传输，而字符用于显示，方便阅读。字符 “p” 保存到硬盘就是一串二进制数据 01110000，占用一个字节的长度 我们用编辑器打开的文本，看到的一个个字符，最终保存在磁盘的时候都是以二进制字节序列形式存起来的。那么从字符到字节的转换过程就叫做编码（encode），反过来叫做解码（decode），两者是一个可逆的过程。编码是为了存储传输，解码是为了方便显示阅读。 3 什么是字符集字符集是一个系统支持的所有抽象字符的集合。它是各种文字和符号的总称，常见的字符集种类包括 ASCII 字符集、GBK 字符集、Unicode字符集等。不同的字符集规定了有限个字符，比如：ASCII 字符集只含有拉丁文字字母，GBK 包含了汉字，而 Unicode 字符集包含了世界上所有的文字符号。 3.1 ASCII:字符集与字符编码的起源ASCII（American Standard Code for Information Interchange，美国信息交换标准代码），一共规定了 128 个字符及对应的二进制转换关系，128 个字符包括了可显示的26个字母（大小写）、10个数字、标点符号以及特殊的控制符，也就是英语与西欧语言中常见的字符，这128个字符用一个字节来表示绰绰有余，因为一个字节可以表示256个字符，所以当前只利用了字节的7位，最高位用来当作奇偶校验。如字符小写 a 对应 01100001，大写 A 对应 01000001。 ASCII 字符集是字母、数字、标点符号以及控制符（回车、换行、退格）等组成的128个字符。 ASCII 字符编码是将这128个字符转换为计算机可识别的二进制数据的一套规则（算法）。 因此，字符集和字符编码的关系：通常来说，字符集同时定义了一套同名的字符编码规则，例如 ASCII 就定义了字符集以及字符编码。但是不是绝对， Unicode 就只定义了字符集，而对应的字符编码是 UTF-8，UTF-16。 通俗讲：字符集为每一个字符分配一个数字序号。例如在ASCII字符集中，字符A被分配成65号，那就是说A的编码值code point是65。而字符编码就是如何将编码值变成二进制计算机可以识别的形式。 3.2 EASCII:扩展的ASCII随着计算机的不断普及，计算机开始被西欧等国家使用，然后西欧语言中还有很多字符不在 ASCII 字符集中。因为 ASCII 只使用了字节的前 7 位，如果把第八位也利用起来，那么可表示的字符个数就是 256。这就是后来的 EASCII（Extended ASCII，延伸美国标准信息交换码），EASCII 码比 ASCII 码扩充出来的符号包括表格符号、计算符号、希腊字母和特殊的拉丁符号。 3.3 GB2312和GBK:满足国人需求的字符集计算机开始普及到了中国，但面临的一个问题就是字符，汉字博大精深，常用汉字有3500个，已经大大超出了 ASCII 字符集所能表示的字符范围了，即使是 EASCII 也显得杯水车薪，1981 年国家标准化管理委员会定了一套字符集叫 GB2312，每个汉字符号由两个字节组成，理论上它可以表示65536个字符，不过它只收录了7445个字符，6763个汉字和682个其他字符，同时它能够兼容 ASCII，ASCII 中定义的字符只占用一个字节的空间。 GB2312 所收录的汉字已经覆盖中国大陆99.75%的使用频率，但是对一些罕见的字和繁体字还有很多少数民族使用的字符都没法处理，于是后来就在 GB2312 的基础上创建了一种叫 GBK 的字符编码，GBK 不仅收录了27484 个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。GBK 是利用了 GB2312 中未被使用的编码空间上进行扩充，所以它能完全兼容 GB2312和 ASCII。而 GB 18030 是现时最新的字符集，兼容 GB 2312-1980 和 GBK， 共收录汉字70244个，采用多字节编码，每个字符可以有1、2、4个字节组成，某种意义上它能容纳161 万个字符，包含繁体汉字以及日韩汉字，单字节与ASCII兼容，双字节与GBK标准兼容。 3.4 Unicode ：统一江湖的字符集尽管我们有了属于自己的字符集和字符编码 GBK，可世界上还有很多国家拥有自己的语言和文字，比如日本用 JIS，台湾用 BIG5，不同国家之间交流起来就很困难，因为没有统一的编码标准，可能同一个字符，在A国家用两字字节存储，而到了B国家是3个字节，这样很容易出现编码问题，于是在 1991 年，国际标准化组织和统一码联盟组织各自开发了 ISO/IEC 10646（USC）和 Unicode 项目，这两个项目的目的都是希望用一种字符集来统一全世界所有字符，不过很快双方都意识到世界上并不需要两个不兼容的字符集。于是他们就编码问题进行了非常友好地会晤，决定彼此把工作内容合并，虽然项目还是独立存在，各自发布各自的标准，但前提是两者必须保持兼容。不过由于 Unicode 这一名字比较好记，因而它使用更为广泛，成为了事实上的统一编码标准。 Unicode 是一个囊括了世界上所有字符的字符集，其中每一个字符都对应有唯一的编码值（code point），注意了：它不是字符编码，仅仅是字符集而已，Unicode 字符如何进行编码，可以是 UTF-8、UTF-16、甚至用 GBK 来编码。 123456789101112注：在python2环境下：>>> a = u"好">>> a u'\u597d' >>> b = a.encode("utf-8")>>> b'\xe5\xa5\xbd' >>>>>> b = a.encode("gbk")>>> b'\xba\xc3' Unicode 本身并没有规定一个字符究竟是用一个还是三个或者四个字节表示。Unicode 只规定了每个字符对应到唯一的代码值（code point），代码值 从 0000 ~ 10FFFF 共 1114112 个值 ，真正存储的时候需要多少个字节是由具体的编码格式决定的。比如：字符 「A」用 UTF-8 的格式编码来存储就只占用1个字节，用 UTF-16 就占用2个字节，而用 UTF-32 存储就占用4个字节。 3.4.1 UTF-8：Unicode编码UTF（ Unicode Transformation Format）编码 和 USC（Universal Coded Character Set） 编码分别是 Unicode 、ISO/IEC 10646 编码体系里面两种编码方式，UCS 分为 UCS-2 和 UCS-4，而 UTF 常见的种类有 UTF-8、UTF-16、UTF-32。因为 Unicode 与 USC 两种字符集是相互兼容的，所以这几种编码格式也有着对应的等值关系 UCS-2 使用两个定长的字节来表示一个字符，UTF-16 也是使用两个字节，不过 UTF-16 是变长的（网上很多错误的说法说 UTF-16是定长的），遇到两个字节没法表示时，会用4个字节来表示，因此 UTF-16 可以看作是在 UCS-2 的基础上扩展而来的。而 UTF-32 与 USC-4 是完全等价的，使用4个字节表示，显然，这种方式浪费的空间比较多。 UTF-8 的优势是：它以单字节为单位用 1~4 个字节来表示一个字符，从首字节就可以判断一个字符的UTF-8编码有几个字节。如果首字节以0开头，肯定是单字节编码，如果以110开头，肯定是双字节编码，如果是1110开头，肯定是三字节编码，以此类推。除了单字节外，多字节UTF-8码的后续字节均以10开头。 1～4 字节的 UTF-8 编码看起来是这样的： 12340xxxxxxx110xxxxx 10xxxxxx1110xxxx 10xxxxxx 10xxxxxx11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 单字节可编码的 Unicode 范围：\u0000\u007F（0127） 双字节可编码的 Unicode 范围：\u0080\u07FF（1282047） 三字节可编码的 Unicode 范围：\u0800\uFFFF（204865535） 四字节可编码的 Unicode 范围：\u10000\u1FFFFF（655362097151） UTF-8 兼容了 ASCII，在数据传输和存储过程中节省了空间，其二是UTF-8 不需要考虑大小端问题。这两点都是 UTF-16 的劣势。不过对于中文字符，用 UTF-8 就要用3个字节，而 UTF-16 只需2个字节。而UTF-16 的优点是在计算字符串长度，执行索引操作时速度会很快。Java 内部使用 UTF-16 编码方案。而 Python3 使用 UTF-8。UTF-8 编码在互联网领域应用更加广泛。 来看一张图，下图是Windows平台保存文件时可选择的字符编码类型，你可以指定系统以什么样的编码格式来存储文件，ANSI 是 ISO 8859-1的超集，之所以在 Windows下有 Unicode 编码这样一种说法，其实是 Windows 的一种错误表示方法，或许是因为历史原因一直沿用至今，其实它真正表示的是 UTF-16 编码，更具体一点是 UTF-16小端，什么是大端和小端呢？ 3.4.2 大端与小端大小端是数据在存储器中的存放顺序，大端模式，是指数据的高字节在前，保存在内存的低地址中，与人类的读写法一致，数据的低字节在后，保存在内存的高地址中，小端与之相反，小端模式，是指数据的高字节在后，保存在内存的高地址中，而数据的低字节在前，保存在内存的低地址中例如，十六进制数值 0x1234567的大端字节序和小端字节序的写法： 至于为什么会有大端和小端之分呢？对于 16 位或者 32 位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节排放的问题，因为不同操作系统读取多字节的顺序不一样，，x86和一般的OS（如windows，FreeBSD,Linux）使用的是小端模式。但比如Mac OS是大端模式。因此就导致了大端存储模式和小端存储模式的存在，两者并没有孰优孰劣。 为什么UTF-8不需要考虑大小端问题？ UTF-8 的编码单元是1个字节，所以就不用考虑字节序问题。而 UTF-16 是用 2个字节来编码 Unicode 字符，编码单位是两个字节，因此需要考虑字节序问题，因为2个字节哪个存高位哪个存低位需要确定。 4 Python2 中的字符编码Python 的诞生时间比 Unicode 还要早几年，所以，Python的第一个版本一直延续Python2.7，Python 的默认编码都是 ASCII。 123>>> import sys>>> sys.getdefaultencoding()'ascii' 所以在 Python 源代码，要能够正常保存中文字符就必须先指定utf-8 或者 gbk 格式 123456# coding=utf-8或者是：#!/usr/bin/python# -*- coding: utf-8 -*- 4.1 str与unicode字符和字节的区别，字符就是一个符号，比如一个汉字、一个字母、一个数字、一个标点都可以称为一个字符，而字节就是字符就是编码之后转换而成的二进制序列，一个字节是8个比特位。例如字符 “p” 存储到硬盘是一串二进制数据 01110000，占用一个字节。字节方便存储和网络传输，而字符用于显示方便阅读。 在Python2中，字符与字节的表示很微妙，两者的界限很模糊，Python2 中把字符串分为 unicode和 str两种类型。本质上str类型是二进制字节序列， unicode类型的字符串是字符，下面的示例代码可以看出 str 类型的 “禅” 打印出来是十六进制的\xec\xf8，对应的二进制字节序列就是11101100 11111000。 12345>>> s = '禅'>>> s'\xec\xf8'>>> type(s) 而 unicode 类型的 u”禅” 对应的 unicode 符号是 u’\u7985’ 12345>>> u = u"禅">>> uu'\u7985'>>> type(u) 我们要把 unicode 字符保存到文件或者传输到网络就需要经过编码处理转换成二进制形式的 str 类型，于是 python 的字符串提供了 encode 方法，从 unicode 转换到 str，反之亦然。 encode: 12345>>> u = u"禅">>> uu'\u7985'>>> u.encode("utf-8")'\xe7\xa6\x85' decode: 1234>>> s = "禅">>> s.decode("utf-8")u'\u7985'>>> 记住 str 本质上其实是一串二进制数据，而 unicode 是字符（符号）。编码（encode）就是把字符（符号）转换为 二进制数据的过程，因此 unicode 到 str 的转换要用 encode 方法，反过来就是用 decode 方法。 encoding always takes a Unicode string and returns a bytes sequence, and decoding always takes a bytes sequence and returns a Unicode string”. 4.2 UnicodeEncodeErrorUnicodeEncodeError 发生在 unicode 字符串转换成 str 字节序列的时候，来看一个例子，把一串 unicode 字符串保存到文件 12345# -*- coding:utf-8 -*-def main(): name = u'Python之禅' f = open("output.txt", "w") f.write(name) 错误日志 UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 6-7: ordinal not in range(128) 为什么会出现 UnicodeEncodeError？ 因为调用 write 方法时，程序会把字符经过编码转换成二进制字节序列，内部会有 unicode 到 str 的编码转换过程，程序会先判断字符串是什么类型，如果是 str，就直接写入文件，不需要编码，因为 str 类型的字符串本身就是一串二进制的字节序列了。如果字符串是 unicode 类型，那么它会先调用 encode 方法把 unicode 字符串转换成二进制形式的 str 类型，才保存到文件，而 Python2中，encode 方法默认使用 ascii 进行 encde. 相当于： 1>>> u"Python之禅".encode("ascii") 但是，我们知道 ASCII 字符集中只包含了128个拉丁字母，不包括中文字符，因此 出现了 ‘ascii’ codec can’t encode characters 的错误。要正确地使用 encode ，就必须指定一个包含了中文字符的字符集，比如：UTF-8、GBK。 12345>>> u"Python之禅".encode("utf-8")'Python\xe4\xb9\x8b\xe7\xa6\x85'>>> u"Python之禅".encode("gbk")'Python\xd6\xae\xec\xf8' 所以要把 unicode 字符串正确地写入文件，就应该预先把字符串进行 UTF-8 或 GBK 编码转换。 12345def main(): name = u'Python之禅' name = name.encode('utf-8') with open("output.txt", "w") as f: f.write(name) 或者直接写str类型的字符串 1234def main(): name = 'Python之禅' with open("output.txt", "w") as f: f.write(name) 当然，把 unicode 字符串正确地写入文件不止一种方式，但原理是一样的，这里不再介绍，把字符串写入数据库，传输到网络都是同样的原理 4.3 UnicodeDecodeErrorUnicodeDecodeError 发生在 str 类型的字节序列解码成 unicode 类型的字符串时 12345678910>>> a = u"禅">>> au'\u7985'>>> b = a.encode("utf-8")>>> b'\xe7\xa6\x85'>>> b.decode("gbk")Traceback (most recent call last): File "", line 1, in UnicodeDecodeError: 'gbk' codec can't decode byte 0x85 in position 2: incomplete multibyte sequence 把一个经过 UTF-8 编码后生成的字节序列 ‘\xe7\xa6\x85’ 再用 GBK 解码转换成 unicode 字符串时，出现 UnicodeDecodeError，因为 （对于中文字符）GBK 编码只占用两个字节，而 UTF-8 占用3个字节，用 GBK 转换时，还多出一个字节，因此它没法解析。避免 UnicodeDecodeError 的关键是保持 编码和解码时用的编码类型一致。 再举一个 UnicodeDecodeError 的例子 1234567>>> x = u"Python">>> y = "之禅">>> x + yTraceback (most recent call last): File "", line 1, in UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)>>> str 与 unicode 字符串 执行 + 操作时，Python 会把 str 类型的字节序列隐式地转换成（解码）成 和 x 一样的 unicode 类型，但Python是使用默认的 ascii 编码来转换的，而 ASCII字符集中不包含有中文，所以报错了。相当于： 1234>>> y.decode('ascii')Traceback (most recent call last): File "", line 1, in UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128) 正确地方式应该是找到一种包含有中文字符的字符编码，比如 UTF-8或者 GBK 显示地把 y 进行解码转换成 unicode 类型 12345>>> x = u"Python">>> y = "之禅">>> y = y.decode("utf-8")>>> x + yu'Python\u4e4b\u7985' 5 python3 中的字符编码Python3对字符串和字符编码进行了很彻底的重构，完全不兼容Python2，同时也很多想迁移到Python3的项目带来了很大的麻烦，Python3 把系统默认编码设置为 UTF-8，字符和二进制字节序列区分得更清晰，分别用 str 和 bytes 表示。文本字符全部用 str 类型表示，str 能表示 Unicode 字符集中所有字符，而二进制字节数据用一种全新的数据类型，用 bytes 来表示，尽管Python2中也有bytes类型，但那只不过是str的一个别名。 5.1 str1234567891011>>> a = "a">>> a'a'>>> type(a)>>> b = "禅">>> b'禅'>>> type(b) 5.2 bytesPython3 中，在字符引号前加‘b’，明确表示这是一个 bytes 类型的对象，实际上它就是一组二进制字节序列组成的数据，bytes 类型可以是 ASCII范围内的字符和其它十六进制形式的字符数据，但不能用中文等非ASCII字符表示。 12345678910111213141516>>> c = b'a'>>> cb'a'>>> type(c)>>> d = b'\xe7\xa6\x85'>>> db'\xe7\xa6\x85'>>> type(d)>>>>>> e = b'禅' File "", line 1SyntaxError: bytes can only contain ASCII literal characters. bytes 类型提供的操作和 str 一样，支持分片、索引、基本数值运算等操作。但是 str 与 bytes 类型的数据不能执行 + 操作，尽管在python2中是可行的。 12345678910111213>>> b"a"+b"c"b'ac'>>> b"a"*2b'aa'>>> b"abcdef\xd6"[1:]b'bcdef\xd6'>>> b"abcdef\xd6"[-1]214>>> b"a" + "b"Traceback (most recent call last): File "", line 1, in TypeError: can't concat bytes to str 5.3 python2 与 python3 字节与字符对比 python2 python3 表现 转换 作用 str bytes 字节 encode 存储 unicode str 字符 decode 显示 总结 字符编码本质上是字符到字节的转换过程 字符集的演进过程是：ascii、eascii、ios8895-x，gb2312… Unicode Unicode是字符集，对应的编码格式有UTF-8，UTF-16 字节序列存储的时候有大小端之分 python2中字符与字节分别用unicode和str类型表示 python3中字符与字节分别用str与bytes表示 参考：https://www.cnblogs.com/vipchenwei/p/6993788.html python 之路，致那些年，我们依然没搞明白的编码 字符编码的前世今生 关于字符编码：ascii、unicode与utf-8 字符编码笔记：ASCII，Unicode 和 UTF-8 编码转化工具 UniCode编码表 https://www.cnblogs.com/work115/p/5924446.html https://www.cnblogs.com/ctztake/p/7230785.html Python2.7中调用print打印var 变量时，操作系统会对var做一定的字符处理：如果var是str类型的变量，则直接将var变量交付给终端进行显示；如果var变量是unicode类型，则操作系统首先将var编码成str类型的对象（编码格式取决于stdout的编码格式），然后再交由终端进行显示。在终端显示时，如果str类型的变量的编码方式和终端设置的编码方式不一致，很可能会出现乱码问题。 str和unicode 转换: str -> decode(‘the_coding_of_str‘) -> unicode unicode -> encode(‘the_coding_you_want‘) -> str 注意：python3字符串默认都是以unicode编码的，print打印时，变量只接受unicode类型，否则不能正常打印，这与python2不同。 python (“打印”，”0001:002”) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端]]></title>
    <url>%2F2019%2F%E5%89%8D%E7%AB%AF%2F2019-%E5%89%8D%E7%AB%AF-%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[1 前言​ 编程就是跟数据打交道，我们需要处理数据，存储数据，展示数据。什么是前端，为什么学前端。 2 web前端概述​ web前端开发是从网页制作演变而来。在互联网的演化进程中，网页制作是Web 1.0时代的产物，早期网站主要内容都是静态，以图片和文字为主，用户使用网站的行为也以浏览为主。随着互联网技术的发展和HTML5、CSS3的应用，现代网页更加美观，交互效果显著，功能更加强大。 ​ 学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言。 HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。 CSS样式是表现。比如标题字体、颜色变化或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。 JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。 3 web服务本质 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django基本流程]]></title>
    <url>%2F2019%2Fdjango%2F2019-django-Django%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1 设计表结构 注：mysql的安装与使用 2 配置数据库2.1 默认SQLite数据库打开mysite/settings.py配置文件，这是整个Django项目的设置中心。Django默认使用SQLite数据库，因为Python源生支持SQLite数据库，所以你无须安装任何程序，就可以直接使用它。 123456789# Database# https://docs.djangoproject.com/en/2.2/ref/settings/#databasesDATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), }} 如果你想使用其他的数据库，请先安装相应的数据库操作模块，并将settings文件中DATABASES位置的’default’的键值进行相应的修改，用于连接你的数据库。其中： ENGINE（引擎）：可以是django.db.backends.sqlite3、django.db.backends.postgresql、django.db.backends.mysql、django.db.backends.oracle，当然其它的也行。 NAME（名称）：类似Mysql数据库管理系统中用于保存项目内容的数据库的名字。如果你使用的是默认的SQLite，那么数据库将作为一个文件将存放在你的本地机器内，此时的NAME应该是这个文件的完整绝对路径包括文件名，默认值os.path.join(BASE_DIR, ’db.sqlite3’)，将把该文件储存在你的项目目录下。 2.2 更换其他数据库注：如果你不是使用默认的SQLite数据库，那么一些诸如USER，PASSWORD和HOST的参数必须手动指定！mysql 示例： 1234567891011121314151617181920# mysite/settings.py# Database# https://docs.djangoproject.com/en/1.11/ref/settings/#databasesimport pymysql # 一定要添加这两行！通过pip install pymysql！pymysql.install_as_MySQLdb()#因为Django连接MySQL时默认使用MySQLdb驱动，但MySQLdb不支持Python3，因此这里将MySQL#驱动设置为pymysql。DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'mysite', 'HOST': '192.168.1.1', 'USER': 'root', 'PASSWORD': 'pwd', 'PORT': '3306', }} 注意： 在使用非SQLite的数据库时，请务必预先在数据库管理系统的提示符交互模式下创建数据库，你可以使用命令：CREATE DATABASE database_name; Django不会自动帮你做这一步工作。 确保你在settings文件中提供的数据库用户具有创建数据库表的权限，因为在接下来的教程中，我们需要自动创建一个test数据表。（在实际项目中也需要确认这一条要求。） 如果你使用的是SQLite，那么你无需做任何预先配置，直接使用就可以了。 2.3 错误错误1： 12345678No module named 'MySQLdb'原因：python3连接MySQL不能再使用mysqldb，取而代之的是pymysql。解决方法：在python的MySQL包中，即路径：C:\Users\adong\AppData\Local\Programs\Python\Python36\Lib\site-packages\Django-2.0.3-py3.6.egg\django\db\backends\mysql下的__init__.py文件中加入：import pymysqlpymysql.install_as_MySQLdb() 错误2： 123456789django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.3 or newer is required; you have 0.7.11.None原因：在解决了错误一以后出现了此错误。解决方法：在python的MySQL包中，即路径：C:\Users\adong\AppData\Local\Programs\Python\Python36\Lib\site-packages\Django-2.0.3-py3.6.egg\django\db\backends\mysql下的 base.py 文件中，注释掉一下两行代码：if version < (1, 3, 3): raise ImproperlyConfigured("mysqlclient 1.3.3 or newer is required; you have %s" % Database.__version__) 错误3： 123python3报错：Attribute Error:str object has no attribut edecode 错误代码：query = query.encode(errors='replace')解决方法：把decode改为encode即可。 3 创建应用3.1 命令创建在 Django 中，每一个应用（app）都是一个 Python 包，并且遵循着相同的约定。Django 自带一个工具，可以帮你生成应用的基础目录结构。 app应用与project项目的区别： 一个app实现某个功能，比如博客、公共档案数据库或者简单的投票系统； 一个project是配置文件和多个app的集合，这些app组合成整个站点； 一个project可以包含多个app； 一个app可以属于多个project！ app的存放位置可以是任何地点，但是通常都将它们放在与manage.py脚本同级的目录下，这样方便导入文件 进入mysite项目根目录，确保与manage.py文件处于同一级，输入下述命令： 1python manage.py startapp appname 系统会自动生成 polls应用的目录，其结构如下： 123456789appname/ __init__.py ---说明app应用是一个包 admin.py ---站点配置 apps.py migrations/ __init__.py models.py ---模型 tests.py views.py ---视图（url-->视图-->models取数据-->视图在将数据给模板） 3.2 pycharm中创建在Pycharm中，没有可以创建app的图形化按钮，需要在下方的Terminal终端中输入命令： python manage.py startapp appname 通过前面在Pycharm中创建工程的方式有个方便之处，点击Terminal后，会自动进入虚拟环境。 注：如果没有进入venv环境，则执行语句报错！ 4 激活应用在settings文件中顶部的INSTALLED_APPS设置项。它列出了所有的项目中被激活的Django应用（app）。你必须将你自定义的app注册在这里。每个应用可以被多个项目使用，并且可以打包和分发给其他人在他们的项目中使用。 默认情况，INSTALLED_APPS中会自动包含下列条目，它们都是Django自动生成的： django.contrib.admin：admin管理后台站点 django.contrib.auth：身份认证系统 django.contrib.contenttypes：内容类型框架 django.contrib.sessions：会话框架 django.contrib.messages：消息框架 django.contrib.staticfiles：静态文件管理框架 上面的一些应用也需要建立一些数据库表，所以在使用它们之前我们要在数据库中创建这些表， migrate命令将遍历INSTALLED_APPS设置中的所有项目，在数据库中创建对应的表，并打印出每一条动作信息 12345678910# Application definitionINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] 5 定义模型模型本质上就是数据库表的布局，再附加一些元数据。 Django通过自定义Python类的形式来定义具体的模型，每个模型的物理存在方式就是一个Python的类Class，每个模型代表数据库中的一张表，每个类的实例代表数据表中的一行数据，类中的每个变量代表数据表中的一列字段。Django通过模型，将Python代码和数据库操作结合起来，实现对SQL查询语言的封装。也就是说，你可以不会管理数据库，可以不会SQL语言，你同样能通过Python的代码进行数据库的操作。Django通过ORM对数据库进行操作，奉行代码优先的理念，将Python程序员和数据库管理员进行分工解耦。 现在编辑myapp/models.py文件 1234567891011121314# polls/models.pyfrom django.db import modelsclass Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published')class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) 注： 首先要引入from django.db import models, 因为每一个类都是django.db.models.Model的子类。每一个字段都是Field类的一个实例。例如用于保存字符数据的CharField和用于保存时间类型的DateTimeField，它们告诉Django每一个字段保存的数据类型。 每一个Field实例的名字就是字段的名字（如： question_text 或者 pub_date ）。在你的Python代码中会使用这个值，你的数据库也会将这个值作为表的列名。 一些Field类必须提供某些特定的参数。例如CharField需要你指定max_length。这不仅是数据库结构的需要，同样也用于数据验证功能。 有必填参数，当然就会有可选参数，比如在votes里我们将其默认值设为0. 最后请注意，我们使用ForeignKey定义了一个外键关系。它告诉Django，每一个Choice关联到一个对应的Question（注意要将外键写在‘多’的一方）。Django支持通用的数据关系：一对一，多对一和多对多。 6 在数据库中生成数据表需要做两步操作 生成迁移文件和执行迁移 6.1 makemigrations1python manage.py makemigrations 通过运行makemigrations命令，Django 会检测你对模型文件的修改，也就是告诉Django你对模型有改动，并且你想把这些改动保存为一个“迁移(migration)”。 migrations是Django保存模型修改记录的文件，这些文件保存在磁盘上。会在 migrations下生成一个0001_initial.py文件，面保存的都是人类可读并且可编辑的内容，方便随时手动修改。 在例子中，它就是polls/migrations/0001_initial.py，你可以打开它看看，里面保存的都是人类可读并且可编辑的内容，方便你随时手动修改。 123注：通过执行python manage.py sqlmigrate appname 0001命令可以看到在migration的时候实际执行的SQL语句是什么。执行python manage.py check命令，它将检查项目中的错误，并不实际进行迁移或者链接数据库的操作 6.2 migrate运行migrate命令，在数据库中进行真正的表操作了。 python manage.py migrate 1234567show databases;use 数据库名称；show tables；select * from 表名；desc 表名；create database databasename；drop database databasename； migrate命令对所有还未实施的迁移记录进行操作，本质上就是将你对模型的修改体现到数据库中具体的表上面。Django通过一张叫做django_migrations的表，记录并跟踪已经实施的migrate动作，通过对比获得哪些migrations尚未提交。 migrations的功能非常强大，允许你随时修改你的模型，而不需要删除或者新建你的数据库或数据表，在不丢失数据的同时，实时动态更新数据库 修改模型时的操作分三步 在models.py中修改模型； 运行python manage.py makemigrations为改动创建迁移记录； 运行python manage.py migrate，将操作同步到数据库。 之所以要将创建和实施迁移的动作分成两个命令两步走是因为你也许要通过版本控制系统（例如github，svn）提交你的项目代码，如果没有一个中间过程的保存文件（migrations），那么github如何知道以及记录、同步、实施你所进行过的模型修改动作呢？毕竟，github不和数据库直接打交道，也没法和你本地的数据库通信。但是分开之后，你只需要将你的migration文件（例如上面的0001）上传到github，它就会知道一切。 6.3 错误1234Django在根据models生成数据库表时报 init() missing 1 required positional argument: 'on_delete'解决办法:在django2.0后，定义外键和一对一关系的时候需要加on_delete选项，此参数为了避免两个表里的数据不一致问题，不然会报错：https://www.cnblogs.com/phyger/p/8035253.html 7 使用模型的API模型、数据库表、 数据库数据之间的使用。 注：一般是在view（视图）中使用，视图通过使用模型的api去获取数据，然后将数据传递给模板，模板经过渲染之后再浏览器进行显示。下面的测试使用python的shell环境进行测试。 7.1 进入Python的shell通过python manage.py shell进入Python的shell环境，相比较直接输入“python”命令的方式进入Python环境，调用manage.py参数能将DJANGO_SETTINGS_MODULE环境变量导入，它将自动按照mysite/settings.py中的设置，配置好你的python shell环境，这样，你就可以导入和调用任何你项目内的模块了。 7.2 导入包12345>>>from myapp.models import Grades,Students #引入我们在模型中定义的类>>>from django.utils import timezone #Django推荐使用timezone.now()代替python内置的datetime.datetime.now()# 这个timezone就来自于Django的依赖库pytz>>>from datetime import * #导入 python自带的datetime模块 7.3 查询所有数据object是模型属性—用于模型对象和数据库交互 . objects = Manager（） 是管理器类型的对象 ,是Model和数据库进行查询的接口。 定义在from django.db import models中用于模型对象和数据库交互是默认自动生成的属性，但我们是可以自定义管理器对象。 如果不自己定义，objects=models.Manager()查询类的属性时都是类名.objects.方法 123>>> Students.objects.all()#现在系统中没有Students对象，数据库中没有数据 7.4 添加数据 1234567>>> grade1=Grades()>>> grade1.gname="python04">>> grade1.gdate=datetime(year=2017,month=7,day=17)>>> grade1.ggirlnum=3>>> grade1.gboynum=70#必须调用save()函数才能在数据库中添加数据>>> grade1.save() 添加数据后，再次进行查询： 12>>> Grades.objects.all() 上面的是一个不可读的内容展示，你无法从中获得任何直观的信息，为此我们需要一点小技巧，让Django在打印对象时显示一些我们指定的信息。 返回myapp/models.py文件，修改一下类，代码如下： 12345678class Grades(models.Model): gname = models.CharField(max_length=20) gdate = models.DateTimeField() ggirlnum = models.IntegerField() gboynum = models.IntegerField() isDelete = models.BooleanField(default=False) def __str__(self): return self.gname 退出shell 环境，然后重新进入，另需要重新导入模块： 12345>>>from myapp.models import Grades,Students >>>from django.utils import timezone >>>from datetime import * >>>Grades.objects.all() 7.5 查看对象Django提供了大量的关键字参数查询API 123456789101112131415161718 >>>Grades.objects.filter(id=1)>>> Grades.objects.filter(gname='python04')>>> Grades.objects.filter(gboynum=33)>>> Grades.objects.filter(ggirlnum=3)# 查询一个不存在的ID，会弹出异常>>> Grades.objects.get(id=3)myapp.models.Grades.DoesNotExist: Grades matching query does not exist.# Django为主键查询提供了一个缩写：pk。与Grades.objects.get(id=1)效果相同>>> Grades.objects.get(pk=1) Django提供了大量的关键字参数查询API pycharm中 .idea文件 7.6 修改数据通过python的属性调用方式，访问模型字段的值 通过修改属性来修改字段的值，然后显式的调用save方法进行保存。 7.7 删除数据 7.8 关联对象 获取关联对象的集合： 问题：如果表的关联很多，一环扣一环怎么办？ 123>>> stu2=Students(sname="jone",sage=30,scontend="我是jone",sgrade=grade1)>>> stu2.save()问题：如果关联不存在，怎么办？ 8 启动服务器 9 admin站点管理​ 很多时候，我们不光要开发针对客户使用的前端页面，还要给后台管理人员提供相应的管理界面。但是大多数时候为你的团队或客户编写用于增加、修改和删除内容的后台管理站点是一件非常乏味的工作并且没有多少创造性，而且也需要花不少的时间和精力。Django最大的优点之一，就是体贴的为你提供了一个基于项目model创建的一个后台管理站点admin。这个界面只给站点管理员使用，并不对大众开放。虽然admin的界面可能不是那么美观，功能不是那么强大，内容不一定符合你的要求，但是它是免费的、现成的，并且还是可定制的 负责添加、修改、删除内容，内容指的是数据，数据库中的数据，通过可视化界面来修改数据。 公告访问：一般不需要 9.1 配置Admin应用 9.2 创建管理员用户 首先，我们需要通过下面的命令，创建一个可以登录admin站点的用户： 1python manage.py createsuperuser 输入用户名： 1Username: admin 输入邮箱地址： 1Email address: xxx@xxx.xxx 输入密码： 123Password: **********Password (again): *********Superuser created successfully. 修改密码： 方法一 在Terminal中执行：python manage.py changepassword your_name（其中“your_name”为你要修改密码的用户名），根据提示内容修改即可。 方法二 进入shell环境，执行： 1234from django.contrib.auth.models import Useru = User.objects.get(username='your_name')u.set_password('new_password')u.save() 比较 方法一有密码强度验证，方法二不会校验密码强度 9.3 启动开发服务器服务器启动后，在浏览器访问http://127.0.0.1:8000/admin/。你就能看到admin的登陆界面了： 在实际环境中，为了站点的安全性，我们一般不能将管理后台的url随便暴露给他人，不能用/admin/这么简单的路径。 打开根url路由文件mysite/urls.py，修改其中admin.site.urls对应的表达式 123456from django.contrib import adminfrom django.urls import pathurlpatterns = [ path('control/', admin.site.urls),] 这样，我们必须访问http://127.0.0.1:8000/control/才能进入admin界面。 9.4 汉化1234LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/shanghai'#注：不需要重启服务，直接刷新页面就好 当前只有两个可编辑的内容：groups和users。它们是django.contrib.auth模块提供的身份认证框架。 9.5 管理数据表9.5.1修改admin.py文件在 app 中存在admin.py文件，进行修改。 导入类（表） 进行注册 12345from django.contrib import adminfrom .models import Grades,Students# Register your models here.admin.site.register(Grades)admin.site.register(Students) 9.5.2 自定义管理界面点击进入 ，界面不友好，进行修改，则需要自定义管理界面： 自定义管理界面步骤： 定义类，继承admin.ModelAdmin 在类中添加属性 注册 问题：admin管理注册的时候，可以所有类一起进行注册吗？ 答：不能，看admin.site.register()函数的参数 属性说明 添加list_display: 123456from django.contrib import adminfrom .models import Grades,Students# Register your models here.class GradesAdmin(admin.ModelAdmin): list_display = ['pk', 'gname', 'gdate', 'ggirlnum', 'gboynum','isDelete']admin.site.register(Grades,GradesAdmin) 添加 list_filter: 1list_filter = ["gname"] 1list_filter = ["gname","gdate"] 添加search_fields 1search_fields = ["gname"] 添加 list_per_page 1list_per_page = 5 区分添加页和修改页 添加页：点击右上角的添加GRADES 修改页:点击具体某一条数据 123fields ：修改显示的顺序fieldsets ：分组显示两者不能同时用，只是针对添加页和修改页起作用 关联对象： 需要三步： 需要 创建一个类，继承admin.TabularInline或者admin.StackedInline 需要设置model和extra两个变量 需要在GradesAdmin类中添加inlines 布尔值显示问题：字段类型为布尔值变量，显示的时候如果想要显示代表的含义，则需要自定义函数： 定义一个函数，进行判断，然后在list_display中将函数传入。 执行动作的位置如图：目前执行动作位置在左上角，可以进行调整。 123# 执行动作的位置actions_on_top = Falseactions_on_bottom = True 9.5.3 使用装饰器进行注册 10 视图的基本使用10.1 概述一个视图就是一个页面，通常提供特定的功能，使用特定的模板。 10.2 编写视图编写一个简单的视图：（没有用到模板） 导入HttpResponse 定义函数 12345from django.http import HttpResponsedef index(request) #第一个参数：一般是requset 请求体 浏览器发送给服务器的#return httpResponse（） 服务器给浏览器返回的内容return HttpResponse("sunck is a good man") 10.3 配置url 修改project目录下的url.py文件 在myapp应用目录下创建一个url.py文件 关于urlconf： https://blog.csdn.net/sinat_38369128/article/details/81702636 第一，目前 路由（url）到视图（View）的流程可以概括为四个步骤： url匹配 正则捕获 变量类型转化 视图调用 Django2.0 和之前相比多了 变量类型转化 这一步骤。 第二，新的path语法可以解决一下以下几个场景： 类型自动转化 公用正则表达式 每个视图至少做两件事之一：返回一个包含请求页面的HttpResponse对象或者弹出一个类似Http404的异常。 11 模板的基本使用 11.1 概述模板是HTML页面，可以根据视图中传过来的数据进行填充。 11.2 创建模板的目录方法1： 在与应用app同级目录下创建一个templates的文件，然后在该目录下创建对应应用的模板目录。 方法2：在应用目录下创建一个新的templates目录，Django会在它里面查找模板文件 11.3 配置模板路径：12345678910111213141516TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, },] 项目的 TEMPLATES配置项描述了 Django 如何载入和渲染模板 'BACKEND': 'django.template.backends.django.DjangoTemplates',默认的设置文件设置了 DjangoTemplates 后端 12BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))#变量__file__表示文件本身，输出的是一个绝对路径 将 APP_DIRS设置成了 True。这一选项将会让 DjangoTemplates 在每个 INSTALLED_APPS 文件夹中寻找 “templates” 子目录 11.4 定义模板12 流程梳理 参考： http://www.liujiangblog.com/blog/36/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django创建项目]]></title>
    <url>%2F2019%2Fdjango%2F2019-django-django%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[1. 在cmd或Linux命令行环境下创建Django项目1.1 创建django工程在windows的cmd环境中(Linux中类同)，新建或者进入你想创建Django项目的目录，然后输入下面的命令： django-admin startproject mysite 这样就会在当前目录下创建一个叫做mysite的Django项目 12345678910D:\test>django-admin startproject mysiteD:\test>dir D:\test 的目录2019/4/20 11:19 .2019/4/20 11:19 ..2019/4/20 11:19 mysite 0 个文件 0 字节 3 个目录 102,160,605,184 可用字节 可以看到Django自动帮我们创建了一个mysite文件夹，这是项目的根目录。 在mysite根目录中，又有一个mysite目录，这是整个项目的配置文件目录（一定不要和同名的根目录搞混淆了），还有一个manage.py文件，是整个项目的管理脚本 1.2 django项目目录说明12345678---mysite 外层的mysite/目录与Django无关，只是你项目的容器，可以任意重命名。 | db.sqlite3 | manage.py 一个命令行工具，可以使我们用多种方式对Django项目进行交互 ---mysite | settings.py 项目的配置文件 | urls.py 项目的url声明 | wsgi.py 项目与wsgi兼容的web服务器入口 | init.py 一个空文件，它告诉python这个目录应该被视为一个python包 1.3 运行django在项目根目录下，运行python manage.py runserver，Django会以127.0.0.1:8000这个默认配置启动开发服务器。 Django提供了一个用于开发的web服务器，使你无需配置一个类似Ngnix的生产服务器，就能让站点运行起来。这是一个由Python编写的轻量级服务器，简易并且不安全，因此不要将它用于生产环境。 注： Django的开发服务器（以后简称服务器）默认运行在内部的8000端口，如果你想指定端口，请在命令中显示给出： 1python manage.py runserver 8080 如果想修改服务器的ip地址 1python manage.py runserver 0:8000 0 是 0.0.0.0 的简写，Django将运行在0.0.0.0:8000上，整个局域网内都将可以访问站点，而不只是是本机 2. 在windows下使用Pycharm创建Django工程2018以后的Pycharm版本都支持同时创建虚拟环境和Django工程 首先打开Pycharm，点击file-->new project，出现下面的对话框，注意下面的红框提示： 在Location处选择工程目录 在New environment using处选择Virtualenv（这可能需要你提前pip install virtualenv进行虚拟工具virtualenv的安装）。通常情况下，虚拟环境会以venv的名字，自动在工程目录下生成。 在Base interpreter处，选择你要使用的Python解释器 下面两个单选框，根据需要自行选择 如果想使用现成的解释器或者虚拟环境，请选择Existing interpreter 再点开下方的More Settings： Template language:选择使用的模板语言，默认Django就行，可选Jinjia。 Templates folder：Pycharm安利给我们的功能，额外创建一个工程级别的模板文件的保存目录，可以不设置，空着，这里使用默认设置吧。 启用Admin，一般勾上。 没什么问题了，就点击Create吧。 下面就是一段时间的等待，Pycharm会帮助我们自动创建虚拟环境，以及安装最新版本的Django。 创建完成之后，进入Pycharm的设置菜单，可以看到当前Django版本是最新的2.2版本。如果你要指定过去的版本，比如2.1、1.11等，那就不能这么操作了，需要在命令行下自己创建虚拟环境并安装django。或者在这里先删除Django，再安装你想要的指定版本。 看下我们当前的状态，注意venv这个虚拟环境目录，以及我们额外创建的templats目录： 点击绿色的三角，启动默认的开发服务器，如果看到欢迎界面，说明一切OK! 注：使用pycharm在离线环境下安装，容易出现问题：因为需要通过pip安装django 问题：在pycharm中settings 这个的作用 参考： pycharm创建django项目 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django安装]]></title>
    <url>%2F2019%2Fdjango%2F2019-django-django%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[1 前言Django是由Python编写的Web框架，依赖Python环境，所以需要提前安装好Python解释器。 进行Python + Django的Web开发，最佳IDE环境是Pycharm Django对Python版本的依赖关系如下表所示： Django 版本 Python 版本 1.8 2.7, 3.2 (until the end of 2016), 3.3, 3.4, 3.5 1.9, 1.10 2.7, 3.4, 3.5 1.11 2.7，3.4，3.5，3.6，3.7 (1.11.17添加) 2.0 3.4，3.5，3.6，3.7 2.1，2.2 3.5, 3.6, 3.7 2 安装Django2.1 通过pip 安装DjangoDjango本质上是Python语言的一个类库，因此可以通过pip工具安装。这也是最简便最好的安装方式。不建议通过下载安装包或者编译源码进行安装的方法，除非你的环境无法连接外部网络。 这里介绍windows系统下pip命令安装方式。 win+r，调出cmd，运行命令：pip install django，自动安装PyPi提供的最新版本。 如果要指定版本，可使用pip install django==2.2这种形式。 在Linux操作系统中，也是一样，使用pip工具包安装Django 2.2 验证进入Python交互式环境 12import djangoprint(django.get_version()) 或者使用pip list命令，查看是否存在Django模块 2.3 配置系统环境变量成功安装Django后，以windows为例，在Python根目录下的Scripts目录中可找到一个django-admin.exe文件，这是Django的核心管理程序，最好将它加入操作系统的环境变量中，这样在以后的调用会比较方便 回到cmd界面，运行django-admin help，能看到下面的内容表示环境变量设置成功。 12345678910111213141516171819202122232425262728293031C:\Users\USER>django-admin helpType 'django-admin help ' for help on a specific subcommand.Available subcommands:[django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations migrate runserver sendtestemail shell showmigrations sqlflush sqlmigrate sqlsequencereset squashmigrations startapp startproject test testserver document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建自己的博客]]></title>
    <url>%2F2019%2F%E5%B7%A5%E5%85%B7%2F2019-%E5%B7%A5%E5%85%B7-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言：技术：Hexo+github 好处： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 准备工作： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 搭建github博客创建仓库 登录github账号后新创建一格式为：你的用户名.github.io 比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了 点击Settings设置，然后往下拉，找到github pages，点击choose a theme选择喜欢主题 在浏览器输入 用户名.github.io访问自己博客 绑定域名配置SSH key hexohexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo 原理​ 由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 hexo常用命令12345678910111213141516171819hexo g # 生成hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的hexo s # 开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容hexo clean #清理public的内容，然后再来重新生成和发布hexo d # 上传hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本缩写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy组合命令：hexo s -g #生成并本地预览hexo d -g #生成并上传 注： 执行hexo d 命令之前，可能需要安装 npm install hexo-deployer-git –save 在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 hexo环境搭建： 安装git 安装nodejs 创建存放hexo组件的目录，然后Git bash here 安装hexo npm install hexo -g hexo -v，检查hexo是否安装成功 初始化文件夹 hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： npm install 安装所需要的组件 将Hexo于Github page 联系起来，设置Git的user name 和email git config --global user.name "qianlongshenyong" git config --global user.email"1320005085@qq.com" 修改 D:\blog\_config.yml 并保存 hexo s 启动服务，在本地4000端口开启服务 在浏览器输入127.0.0.1:4000访问博客主页 使用Hexo修改博客主题操作步骤 选择博客主题https://hexo.io/themes/ 选择tomotoes主题 复制主题链接， D:\blog\themes,右键选择git bash here 下载所选主题git clone https://github.com/Tomotoes/hexo-theme-tomotoes.git 修改主题名称为tomotoes 修改 D:\blog\_config.yml 中theme并保存 然后在==blog目录==下打开git输入hexo s，本地预览效果. 修改主题配置按照https://github.com/Tomotoes/hexo-theme-tomotoes.git有部署文档 依赖安装还是在 Hexo 根目录，如果以下插件已安装过，无需再次安装。 Less主题默认使用 less 作为 css 预处理工具。 1$ npm install hexo-renderer-less --save Feed用于生成 rss。 1$ npm install hexo-generator-feed --save Json-content用于生成静态站点数据，用作站内搜索的数据源。 1$ npm install hexo-generator-json-content --save QRCode用于生成微信分享二维码。 1$ npm install hexo-helper-qrcode --save hexo-wordcount用来显示文章更多信息，比如：字数，阅读时间 1npm install hexo-wordcount --save hexo-abbrlink文章唯一链接，有利于SEO，主题脚本也对其有依赖 1npm install hexo-abbrlink --save hexo-filter-github-emojisEmoji插件，让文章更生动 1npm install hexo-filter-github-emojis --save 安装完成后再次运行hexo s 开启页面标签页1hexo new page tags 修改 hexo/source/tags/index.md 的元数据 12layout: tagscomments: false 分类页1hexo new page categories 修改 hexo/source/categories/index.md 的元数据 12layout: categoriescomments: false 关于页1hexo new page about 修改 hexo/source/about/index.md 的元数据 123layout: aboutcomments: truereward: false 根据需求修改主题的配置 修改 `D:\blog_config.yml 1234567title: subtitle:description:keywords:author: peteremial: 1320005085@qq.comurl: 保存预览 npm install –save hexo-deployer-git hexo d –g 关于_config.ymlhexo的_config.yml站点配置文件，也就是站点根目录下的_config.yml配置文件 主题的_config.yml主题配置文件，位于theme文件夹中对应主题的文件夹下的_config.yml。 设置主页的Menu设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，它将用于匹配图标以及翻译。 菜单示例配置 1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 参考：https://blog.csdn.net/tonydandelion2014/article/details/61615898 hexo写博客配置完之后，有两种方法写博客。 方法1 通过hexo命令定位到blog目录下，执行hexo new 'my-first-blog'hexo会帮我们在_posts下生成相关md文件,我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 方法2 自己创建md文件通过typora等md编辑器自己创建md文件，但是必须符合以下开头。 12345678910---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---注:冒号后面必须要有空格 这是yaml语法的规定 其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 hexo new page 'postName'命令和hexo new 'postName'有什么区别呢 最终部署时生成：hexo\public\my-second-blog\index.html，但是它不会作为文章出现在博文目录。 如何让博文列表不显示全部内容默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？ 图片设置问题解决方式是使用CodeFalling/hexo-asset-image插件。 1. post_asset_folder首先确认_config.yml中有post_asset_folder:true。 Hexo提供了一种更方便管理Asset的设定：post_asset_folder 当您设置post_asset_folder为true参数后，在建立文件时，Hexo 会自动建立一个与文章同名的文件夹；以前的文章也可以自己手动创建同名文件夹。 2. 安装 hexo-asset-image在hexo的目录下执行 1npm install https://github.com/CodeFalling/hexo-asset-image --save 3. 使用完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下： 123本地图片测试├── logo.jpg本地图片测试.md 这样的目录结构（目录名和文章名一致），只要使用 1![](本地图片测试/logo.jpg) 就可以插入图片。其中[]里面不写文字则没有图片标题。 生成的结构为 123public/2016/3/9/本地图片测试 ├── index.html ├── logo.jpg 同时，生成的 html 是 1![](/2016/3/9/本地图片测试/logo.jpg) 而不是愚蠢的 1![](本地图片测试/logo.jpg) 个人喜欢typora编辑器，在偏好设置中将图片插入设置为如下：然后只需将后缀.assets删除，即可与hexo文件夹名称相同。 常见问题： 输入hexo d –g 提示找不到git 解决办法：npm install –save hexo-deployer-git 点击主页或者归档显示找不到页面 解决办法：主题设置中有关于开启页面的指令 图片显示不出来问题 解决办法：采用CodeFalling/hexo-asset-image 参考： https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#hexo%E7%AE%80%E4%BB%8B https://blog.csdn.net/sinat_37781304/article/details/82729029 https://foxgrin.github.io/posts/29757/ https://blog.annieyu.com/posts/3333782006.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
